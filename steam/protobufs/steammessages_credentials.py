# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: steammessages_credentials.proto
# plugin: python-betterproto

from dataclasses import dataclass
from typing import List

import betterproto


@dataclass
class CCredentials_TestAvailablePassword_Request(betterproto.Message):
    password: str = betterproto.string_field(1)
    sha_digest_password: bytes = betterproto.bytes_field(2)
    account_name: str = betterproto.string_field(3)


@dataclass
class CCredentials_TestAvailablePassword_Response(betterproto.Message):
    is_valid: bool = betterproto.bool_field(3)


@dataclass
class CCredentials_GetSteamGuardDetails_Request(betterproto.Message):
    include_new_authentications: bool = betterproto.bool_field(1)
    webcookie: str = betterproto.string_field(2)
    timestamp_minimum_wanted: float = betterproto.fixed32_field(3)
    ipaddress: int = betterproto.int32_field(4)


@dataclass
class CCredentials_GetSteamGuardDetails_Response(betterproto.Message):
    is_steamguard_enabled: bool = betterproto.bool_field(1)
    timestamp_steamguard_enabled: float = betterproto.fixed32_field(2)
    deprecated_newauthentication: List[
        "CCredentials_GetSteamGuardDetails_ResponseNewAuthentication"
    ] = betterproto.message_field(3)
    deprecated_machine_name_userchosen: str = betterproto.string_field(4)
    deprecated_timestamp_machine_steamguard_enabled: float = betterproto.fixed32_field(
        5
    )
    deprecated_authentication_exists_from_geoloc_before_mintime: bool = betterproto.bool_field(
        6
    )
    deprecated_machine_id: int = betterproto.uint64_field(7)
    session_data: List[
        "CCredentials_GetSteamGuardDetails_ResponseSessionData"
    ] = betterproto.message_field(8)
    is_twofactor_enabled: bool = betterproto.bool_field(9)
    timestamp_twofactor_enabled: float = betterproto.fixed32_field(10)
    is_phone_verified: bool = betterproto.bool_field(11)


@dataclass
class CCredentials_GetSteamGuardDetails_ResponseNewAuthentication(betterproto.Message):
    timestamp_steamguard_enabled: float = betterproto.fixed32_field(1)
    is_web_cookie: bool = betterproto.bool_field(2)
    ipaddress: int = betterproto.int32_field(3)
    geoloc_info: str = betterproto.string_field(4)
    is_remembered: bool = betterproto.bool_field(5)
    machine_name_user_supplied: str = betterproto.string_field(6)
    status: int = betterproto.int32_field(7)


@dataclass
class CCredentials_GetSteamGuardDetails_ResponseSessionData(betterproto.Message):
    machine_id: int = betterproto.uint64_field(1)
    machine_name_userchosen: str = betterproto.string_field(2)
    timestamp_machine_steamguard_enabled: float = betterproto.fixed32_field(3)
    authentication_exists_from_geoloc_before_mintime: bool = betterproto.bool_field(4)
    newauthentication: List[
        "CCredentials_GetSteamGuardDetails_ResponseNewAuthentication"
    ] = betterproto.message_field(5)
    authentication_exists_from_same_ip_before_mintime: bool = betterproto.bool_field(6)
    public_ipv4: int = betterproto.uint32_field(7)
    public_ip_address: str = betterproto.string_field(8)


@dataclass
class CCredentials_NewMachineNotificationDialog_Request(betterproto.Message):
    is_approved: bool = betterproto.bool_field(1)
    is_wizard_complete: bool = betterproto.bool_field(2)


@dataclass
class CCredentials_NewMachineNotificationDialog_Response(betterproto.Message):
    pass


@dataclass
class CCredentials_ValidateEmailAddress_Request(betterproto.Message):
    stoken: str = betterproto.string_field(1)


@dataclass
class CCredentials_ValidateEmailAddress_Response(betterproto.Message):
    was_validated: bool = betterproto.bool_field(1)


@dataclass
class CCredentials_SteamGuardPhishingReport_Request(betterproto.Message):
    param_string: str = betterproto.string_field(1)
    ipaddress_actual: int = betterproto.uint32_field(2)


@dataclass
class CCredentials_SteamGuardPhishingReport_Response(betterproto.Message):
    ipaddress_loginattempt: int = betterproto.uint32_field(1)
    countryname_loginattempt: str = betterproto.string_field(2)
    statename_loginattempt: str = betterproto.string_field(3)
    cityname_loginattempt: str = betterproto.string_field(4)
    ipaddress_actual: int = betterproto.uint32_field(5)
    countryname_actual: str = betterproto.string_field(6)
    statename_actual: str = betterproto.string_field(7)
    cityname_actual: str = betterproto.string_field(8)
    steamguard_code: str = betterproto.string_field(9)


@dataclass
class CCredentials_LastCredentialChangeTime_Request(betterproto.Message):
    user_changes_only: bool = betterproto.bool_field(1)


@dataclass
class CCredentials_LastCredentialChangeTime_Response(betterproto.Message):
    timestamp_last_password_change: float = betterproto.fixed32_field(1)
    timestamp_last_email_change: float = betterproto.fixed32_field(2)
    timestamp_last_password_reset: float = betterproto.fixed32_field(3)


@dataclass
class CCredentials_GetAccountAuthSecret_Request(betterproto.Message):
    pass


@dataclass
class CCredentials_GetAccountAuthSecret_Response(betterproto.Message):
    secret_id: int = betterproto.int32_field(1)
    secret: bytes = betterproto.bytes_field(2)


class CredentialsStub(betterproto.ServiceStub):
    async def test_available_password(
        self,
        *,
        password: str = "",
        sha_digest_password: bytes = b"",
        account_name: str = "",
    ) -> CCredentials_TestAvailablePassword_Response:
        request = CCredentials_TestAvailablePassword_Request()
        request.password = password
        request.sha_digest_password = sha_digest_password
        request.account_name = account_name

        return await self._unary_unary(
            "/.Credentials/TestAvailablePassword",
            request,
            CCredentials_TestAvailablePassword_Response,
        )

    async def get_steam_guard_details(
        self,
        *,
        include_new_authentications: bool = False,
        webcookie: str = "",
        timestamp_minimum_wanted: float = 0,
        ipaddress: int = 0,
    ) -> CCredentials_GetSteamGuardDetails_Response:
        request = CCredentials_GetSteamGuardDetails_Request()
        request.include_new_authentications = include_new_authentications
        request.webcookie = webcookie
        request.timestamp_minimum_wanted = timestamp_minimum_wanted
        request.ipaddress = ipaddress

        return await self._unary_unary(
            "/.Credentials/GetSteamGuardDetails",
            request,
            CCredentials_GetSteamGuardDetails_Response,
        )

    async def new_machine_notification_dialog_result(
        self, *, is_approved: bool = False, is_wizard_complete: bool = False
    ) -> CCredentials_NewMachineNotificationDialog_Response:
        request = CCredentials_NewMachineNotificationDialog_Request()
        request.is_approved = is_approved
        request.is_wizard_complete = is_wizard_complete

        return await self._unary_unary(
            "/.Credentials/NewMachineNotificationDialogResult",
            request,
            CCredentials_NewMachineNotificationDialog_Response,
        )

    async def validate_email_address(
        self, *, stoken: str = ""
    ) -> CCredentials_ValidateEmailAddress_Response:
        request = CCredentials_ValidateEmailAddress_Request()
        request.stoken = stoken

        return await self._unary_unary(
            "/.Credentials/ValidateEmailAddress",
            request,
            CCredentials_ValidateEmailAddress_Response,
        )

    async def steam_guard_phishing_report(
        self, *, param_string: str = "", ipaddress_actual: int = 0
    ) -> CCredentials_SteamGuardPhishingReport_Response:
        request = CCredentials_SteamGuardPhishingReport_Request()
        request.param_string = param_string
        request.ipaddress_actual = ipaddress_actual

        return await self._unary_unary(
            "/.Credentials/SteamGuardPhishingReport",
            request,
            CCredentials_SteamGuardPhishingReport_Response,
        )

    async def get_credential_change_time_details(
        self, *, user_changes_only: bool = False
    ) -> CCredentials_LastCredentialChangeTime_Response:
        request = CCredentials_LastCredentialChangeTime_Request()
        request.user_changes_only = user_changes_only

        return await self._unary_unary(
            "/.Credentials/GetCredentialChangeTimeDetails",
            request,
            CCredentials_LastCredentialChangeTime_Response,
        )

    async def get_account_auth_secret(
        self,
    ) -> CCredentials_GetAccountAuthSecret_Response:
        request = CCredentials_GetAccountAuthSecret_Request()

        return await self._unary_unary(
            "/.Credentials/GetAccountAuthSecret",
            request,
            CCredentials_GetAccountAuthSecret_Response,
        )
