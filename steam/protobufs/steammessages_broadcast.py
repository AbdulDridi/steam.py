# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: steammessages_broadcast.proto
# plugin: python-betterproto

from dataclasses import dataclass
from typing import List, Optional

import betterproto

from .steammessages_unified_base import NoResponse


class EBroadcastWatchLocation(betterproto.Enum):
    k_EBroadcastWatchLocation_Invalid = 0
    k_EBroadcastWatchLocation_SteamTV_Tab = 1
    k_EBroadcastWatchLocation_SteamTV_WatchParty = 2
    k_EBroadcastWatchLocation_Chat_Tab = 3
    k_EBroadcastWatchLocation_Chat_WatchParty = 4
    k_EBroadcastWatchLocation_CommunityPage = 5
    k_EBroadcastWatchLocation_StoreAppPage = 6
    k_EBroadcastWatchLocation_InGame = 7
    k_EBroadcastWatchLocation_BigPicture = 8
    k_EBroadcastWatchLocation_SalesPage = 9
    k_EBroadcastWatchLocation_CuratorPage = 10
    k_EBroadcastWatchLocation_DeveloperPage = 11
    k_EBroadcastWatchLocation_Chat_Friends = 12
    k_EBroadcastWatchLocation_SteamTV_Web = 13


class EBroadcastChatPermission(betterproto.Enum):
    k_EBroadcastChatPermissionPublic = 0
    k_EBroadcastChatPermissionOwnsApp = 1


class CBroadcast_WatchBroadcast_ResponseEWatchResponse(betterproto.Enum):
    k_EWatchResponseReady = 1
    k_EWatchResponseNotAvailable = 2
    k_EWatchResponseWaitingForApproval = 3
    k_EWatchResponseWaitingForStart = 4
    k_EWatchResponseInvalidSession = 5
    k_EWatchResponseTooManyBroadcasts = 6
    k_EWatchResponseWaitingForReconnect = 7
    k_EWatchResponseSystemNotSupported = 8
    k_EWatchResponseUserRestricted = 9
    k_EWatchResponseClientOutOfDate = 10
    k_EWatchResponsePoorUploadQuality = 11
    k_EWatchResponseMissingSubscription = 12


class CBroadcast_BroadcastViewerState_NotificationEViewerState(betterproto.Enum):
    k_EViewerNeedsApproval = 1
    k_EViewerWatching = 2
    k_EViewerLeft = 3


@dataclass
class CBroadcast_BeginBroadcastSession_Request(betterproto.Message):
    permission: int = betterproto.int32_field(1)
    gameid: int = betterproto.uint64_field(2)
    client_instance_id: int = betterproto.uint64_field(3)
    title: str = betterproto.string_field(4)
    cellid: int = betterproto.uint32_field(5)
    rtmp_token: int = betterproto.uint64_field(6)
    thumbnail_upload: bool = betterproto.bool_field(7)
    client_beta: str = betterproto.string_field(8)
    sysid: int = betterproto.uint32_field(9)


@dataclass
class CBroadcast_BeginBroadcastSession_Response(betterproto.Message):
    broadcast_id: float = betterproto.fixed64_field(1)
    thumbnail_upload_address: str = betterproto.string_field(2)
    thumbnail_upload_token: str = betterproto.string_field(3)
    thumbnail_interval_seconds: int = betterproto.uint32_field(4)
    heartbeat_interval_seconds: int = betterproto.uint32_field(5)


@dataclass
class CBroadcast_EndBroadcastSession_Request(betterproto.Message):
    broadcast_id: float = betterproto.fixed64_field(1)


@dataclass
class CBroadcast_EndBroadcastSession_Response(betterproto.Message):
    pass


@dataclass
class CBroadcast_StartBroadcastUpload_Request(betterproto.Message):
    broadcast_id: float = betterproto.fixed64_field(1)
    cellid: int = betterproto.uint32_field(2)
    as_rtmp: bool = betterproto.bool_field(3)
    delay_seconds: int = betterproto.uint32_field(4)
    rtmp_token: int = betterproto.uint64_field(5)
    upload_ip_address: int = betterproto.uint32_field(6)
    is_replay: bool = betterproto.bool_field(7)
    sysid: int = betterproto.uint32_field(8)


@dataclass
class CBroadcast_StartBroadcastUpload_Response(betterproto.Message):
    upload_token: str = betterproto.string_field(1)
    upload_address: str = betterproto.string_field(2)
    broadcast_upload_id: float = betterproto.fixed64_field(3)
    enable_replay: bool = betterproto.bool_field(6)
    http_address: str = betterproto.string_field(7)


@dataclass
class CBroadcast_NotifyBroadcastUploadStop_Notification(betterproto.Message):
    broadcast_upload_id: float = betterproto.fixed64_field(1)
    upload_result: int = betterproto.uint32_field(2)


@dataclass
class CBroadcast_WatchBroadcast_Request(betterproto.Message):
    steamid: float = betterproto.fixed64_field(1)
    existing_broadcast_id: float = betterproto.fixed64_field(2)
    viewer_token: float = betterproto.fixed64_field(3)
    client_ip: int = betterproto.uint32_field(4)
    client_cell: int = betterproto.uint32_field(5)
    watch_location: "EBroadcastWatchLocation" = betterproto.enum_field(6)
    is_webrtc: bool = betterproto.bool_field(7)


@dataclass
class CBroadcast_WatchBroadcast_Response(betterproto.Message):
    response: "CBroadcast_WatchBroadcast_ResponseEWatchResponse" = betterproto.enum_field(
        1
    )
    mpd_url: str = betterproto.string_field(2)
    broadcast_id: float = betterproto.fixed64_field(3)
    gameid: int = betterproto.uint64_field(4)
    title: str = betterproto.string_field(5)
    num_viewers: int = betterproto.uint32_field(6)
    permission: int = betterproto.int32_field(7)
    is_rtmp: bool = betterproto.bool_field(8)
    seconds_delay: int = betterproto.int32_field(9)
    viewer_token: float = betterproto.fixed64_field(10)
    hls_m3u8_master_url: str = betterproto.string_field(11)
    heartbeat_interval: int = betterproto.int32_field(12)
    thumbnail_url: str = betterproto.string_field(13)
    is_webrtc: bool = betterproto.bool_field(14)
    webrtc_session_id: float = betterproto.fixed64_field(15)
    webrtc_offer_sdp: str = betterproto.string_field(16)
    webrtc_turn_server: str = betterproto.string_field(17)
    is_replay: bool = betterproto.bool_field(18)
    duration: int = betterproto.int32_field(19)


@dataclass
class CBroadcast_HeartbeatBroadcast_Notification(betterproto.Message):
    steamid: float = betterproto.fixed64_field(1)
    broadcast_id: float = betterproto.fixed64_field(2)
    viewer_token: float = betterproto.fixed64_field(3)
    representation: int = betterproto.uint32_field(4)


@dataclass
class CBroadcast_StopWatchingBroadcast_Notification(betterproto.Message):
    steamid: float = betterproto.fixed64_field(1)
    broadcast_id: float = betterproto.fixed64_field(2)
    viewer_token: float = betterproto.fixed64_field(3)


@dataclass
class CBroadcast_GetBroadcastStatus_Request(betterproto.Message):
    steamid: float = betterproto.fixed64_field(1)
    broadcast_id: float = betterproto.fixed64_field(2)


@dataclass
class CBroadcast_GetBroadcastStatus_Response(betterproto.Message):
    gameid: int = betterproto.uint64_field(1)
    title: str = betterproto.string_field(2)
    num_viewers: int = betterproto.uint32_field(3)
    permission: int = betterproto.int32_field(4)
    is_rtmp: bool = betterproto.bool_field(5)
    seconds_delay: int = betterproto.int32_field(6)
    is_publisher: bool = betterproto.bool_field(7)
    thumbnail_url: str = betterproto.string_field(8)
    update_interval: int = betterproto.int32_field(9)
    is_uploading: bool = betterproto.bool_field(10)
    duration: int = betterproto.uint32_field(11)
    is_replay: bool = betterproto.bool_field(12)
    is_capturing_vod: bool = betterproto.bool_field(13)
    is_store_whitelisted: bool = betterproto.bool_field(14)


@dataclass
class CBroadcast_GetBroadcastThumbnail_Request(betterproto.Message):
    steamid: float = betterproto.fixed64_field(1)
    broadcast_id: float = betterproto.fixed64_field(2)


@dataclass
class CBroadcast_GetBroadcastThumbnail_Response(betterproto.Message):
    thumbnail_url: str = betterproto.string_field(1)
    update_interval: int = betterproto.int32_field(2)
    num_viewers: int = betterproto.int32_field(3)
    duration: int = betterproto.int32_field(4)


@dataclass
class CBroadcast_InviteToBroadcast_Request(betterproto.Message):
    steamid: float = betterproto.fixed64_field(1)
    approval_response: bool = betterproto.bool_field(2)


@dataclass
class CBroadcast_InviteToBroadcast_Response(betterproto.Message):
    success: bool = betterproto.bool_field(1)


@dataclass
class CBroadcast_SendBroadcastStateToServer_Request(betterproto.Message):
    permission: int = betterproto.int32_field(1)
    gameid: int = betterproto.uint64_field(2)
    title: str = betterproto.string_field(3)
    game_data_config: str = betterproto.string_field(4)


@dataclass
class CBroadcast_SendBroadcastStateToServer_Response(betterproto.Message):
    pass


@dataclass
class CBroadcast_NotifyBroadcastSessionHeartbeat_Notification(betterproto.Message):
    broadcast_id: float = betterproto.fixed64_field(1)


@dataclass
class CBroadcast_GetBroadcastChatInfo_Request(betterproto.Message):
    steamid: float = betterproto.fixed64_field(1)
    broadcast_id: float = betterproto.fixed64_field(2)
    client_ip: int = betterproto.uint32_field(3)
    client_cell: int = betterproto.uint32_field(4)


@dataclass
class CBroadcast_GetBroadcastChatInfo_Response(betterproto.Message):
    chat_id: float = betterproto.fixed64_field(1)
    view_url_template: str = betterproto.string_field(3)
    flair_group_ids: List[int] = betterproto.uint32_field(4)


@dataclass
class CBroadcast_PostChatMessage_Request(betterproto.Message):
    chat_id: float = betterproto.fixed64_field(1)
    message: str = betterproto.string_field(2)
    instance_id: int = betterproto.uint32_field(3)
    language: int = betterproto.uint32_field(4)
    country_code: str = betterproto.string_field(5)


@dataclass
class CBroadcast_PostChatMessage_Response(betterproto.Message):
    persona_name: str = betterproto.string_field(1)
    in_game: bool = betterproto.bool_field(2)
    result: int = betterproto.int32_field(3)
    cooldown_time_seconds: int = betterproto.int32_field(4)


@dataclass
class CBroadcast_UpdateChatMessageFlair_Request(betterproto.Message):
    chat_id: float = betterproto.fixed64_field(1)
    flair: str = betterproto.string_field(2)


@dataclass
class CBroadcast_UpdateChatMessageFlair_Response(betterproto.Message):
    result: int = betterproto.int32_field(1)
    chat_id: float = betterproto.fixed64_field(2)
    flair: str = betterproto.string_field(3)


@dataclass
class CBroadcast_MuteBroadcastChatUser_Request(betterproto.Message):
    chat_id: float = betterproto.fixed64_field(1)
    user_steamid: float = betterproto.fixed64_field(2)
    muted: bool = betterproto.bool_field(3)


@dataclass
class CBroadcast_MuteBroadcastChatUser_Response(betterproto.Message):
    pass


@dataclass
class CBroadcast_RemoveUserChatText_Request(betterproto.Message):
    chat_id: float = betterproto.fixed64_field(1)
    user_steamid: float = betterproto.fixed64_field(2)


@dataclass
class CBroadcast_RemoveUserChatText_Response(betterproto.Message):
    pass


@dataclass
class CBroadcast_GetBroadcastChatUserNames_Request(betterproto.Message):
    chat_id: float = betterproto.fixed64_field(1)
    user_steamid: List[float] = betterproto.fixed64_field(2)


@dataclass
class CBroadcast_GetBroadcastChatUserNames_Response(betterproto.Message):
    persona_names: List[
        "CBroadcast_GetBroadcastChatUserNames_ResponsePersonaName"
    ] = betterproto.message_field(1)


@dataclass
class CBroadcast_GetBroadcastChatUserNames_ResponsePersonaName(betterproto.Message):
    steam_id: float = betterproto.fixed64_field(1)
    persona: str = betterproto.string_field(2)


@dataclass
class CBroadcast_StartBuildClip_Request(betterproto.Message):
    steamid: float = betterproto.fixed64_field(1)
    broadcast_session_id: float = betterproto.fixed64_field(2)
    first_segment: int = betterproto.int32_field(3)
    num_segments: int = betterproto.int32_field(4)
    clip_description: str = betterproto.string_field(5)


@dataclass
class CBroadcast_StartBuildClip_Response(betterproto.Message):
    broadcast_clip_id: float = betterproto.fixed64_field(1)


@dataclass
class CBroadcast_GetBuildClipStatus_Request(betterproto.Message):
    broadcast_clip_id: float = betterproto.fixed64_field(1)


@dataclass
class CBroadcast_GetBuildClipStatus_Response(betterproto.Message):
    pass


@dataclass
class CBroadcast_SetClipDetails_Request(betterproto.Message):
    broadcast_clip_id: int = betterproto.uint64_field(1)
    start_time: int = betterproto.uint32_field(2)
    end_time: int = betterproto.uint32_field(3)
    video_description: str = betterproto.string_field(4)


@dataclass
class CBroadcast_SetClipDetails_Response(betterproto.Message):
    pass


@dataclass
class CBroadcast_GetClipDetails_Request(betterproto.Message):
    broadcast_clip_id: int = betterproto.uint64_field(1)


@dataclass
class CBroadcast_GetClipDetails_Response(betterproto.Message):
    broadcast_clip_id: int = betterproto.uint64_field(1)
    video_id: int = betterproto.uint64_field(2)
    channel_id: int = betterproto.uint64_field(3)
    app_id: int = betterproto.uint32_field(4)
    accountid_broadcaster: int = betterproto.uint32_field(5)
    accountid_clipmaker: int = betterproto.uint32_field(6)
    video_description: str = betterproto.string_field(7)
    start_time: int = betterproto.uint32_field(8)
    length_milliseconds: int = betterproto.uint32_field(9)
    thumbnail_path: str = betterproto.string_field(10)


@dataclass
class CBroadcast_SetRTMPInfo_Request(betterproto.Message):
    broadcast_permission: int = betterproto.int32_field(1)
    update_token: bool = betterproto.bool_field(2)
    broadcast_delay: int = betterproto.int32_field(3)
    app_id: int = betterproto.uint32_field(4)
    required_app_id: int = betterproto.uint32_field(5)
    broadcast_chat_permission: "EBroadcastChatPermission" = betterproto.enum_field(6)
    broadcast_buffer: int = betterproto.int32_field(7)
    steamid: float = betterproto.fixed64_field(8)
    chat_rate_limit: int = betterproto.uint32_field(9)
    enable_replay: bool = betterproto.bool_field(10)


@dataclass
class CBroadcast_SetRTMPInfo_Response(betterproto.Message):
    pass


@dataclass
class CBroadcast_GetRTMPInfo_Request(betterproto.Message):
    ip: int = betterproto.uint32_field(1)
    steamid: float = betterproto.fixed64_field(2)


@dataclass
class CBroadcast_GetRTMPInfo_Response(betterproto.Message):
    broadcast_permission: int = betterproto.int32_field(1)
    rtmp_host: str = betterproto.string_field(2)
    rtmp_token: str = betterproto.string_field(3)
    broadcast_delay: int = betterproto.int32_field(4)
    app_id: int = betterproto.uint32_field(5)
    required_app_id: int = betterproto.uint32_field(6)
    broadcast_chat_permission: "EBroadcastChatPermission" = betterproto.enum_field(7)
    broadcast_buffer: int = betterproto.int32_field(8)
    steamid: float = betterproto.fixed64_field(9)
    chat_rate_limit: int = betterproto.uint32_field(10)
    enable_replay: bool = betterproto.bool_field(11)


@dataclass
class CBroadcast_WebRTCHaveTURNServer_Notification(betterproto.Message):
    broadcast_session_id: float = betterproto.fixed64_field(1)
    turn_server: str = betterproto.string_field(2)


@dataclass
class CBroadcast_WebRTCStartResult_Request(betterproto.Message):
    webrtc_session_id: float = betterproto.fixed64_field(1)
    started: bool = betterproto.bool_field(2)
    offer: str = betterproto.string_field(3)
    resolution_x: int = betterproto.uint32_field(4)
    resolution_y: int = betterproto.uint32_field(5)
    fps: int = betterproto.uint32_field(6)


@dataclass
class CBroadcast_WebRTCStartResult_Response(betterproto.Message):
    pass


@dataclass
class CBroadcast_WebRTCStopped_Request(betterproto.Message):
    webrtc_session_id: float = betterproto.fixed64_field(1)


@dataclass
class CBroadcast_WebRTCStopped_Response(betterproto.Message):
    pass


@dataclass
class CBroadcast_WebRTCSetAnswer_Request(betterproto.Message):
    broadcaster_steamid: float = betterproto.fixed64_field(1)
    webrtc_session_id: float = betterproto.fixed64_field(2)
    answer: str = betterproto.string_field(3)


@dataclass
class CBroadcast_WebRTCSetAnswer_Response(betterproto.Message):
    pass


@dataclass
class CBroadcast_WebRTCLookupTURNServer_Request(betterproto.Message):
    cellid: int = betterproto.uint32_field(1)


@dataclass
class CBroadcast_WebRTCLookupTURNServer_Response(betterproto.Message):
    turn_server: str = betterproto.string_field(1)


@dataclass
class CBroadcast_WebRTC_Candidate(betterproto.Message):
    sdp_mid: str = betterproto.string_field(1)
    sdp_mline_index: int = betterproto.int32_field(2)
    candidate: str = betterproto.string_field(3)


@dataclass
class CBroadcast_WebRTCAddHostCandidate_Request(betterproto.Message):
    webrtc_session_id: float = betterproto.fixed64_field(1)
    candidate: "CBroadcast_WebRTC_Candidate" = betterproto.message_field(2)


@dataclass
class CBroadcast_WebRTCAddHostCandidate_Response(betterproto.Message):
    pass


@dataclass
class CBroadcast_WebRTCAddViewerCandidate_Request(betterproto.Message):
    broadcaster_steamid: float = betterproto.fixed64_field(1)
    webrtc_session_id: float = betterproto.fixed64_field(2)
    candidate: "CBroadcast_WebRTC_Candidate" = betterproto.message_field(3)


@dataclass
class CBroadcast_WebRTCAddViewerCandidate_Response(betterproto.Message):
    pass


@dataclass
class CBroadcast_WebRTCGetHostCandidates_Request(betterproto.Message):
    broadcaster_steamid: float = betterproto.fixed64_field(1)
    webrtc_session_id: float = betterproto.fixed64_field(2)
    candidate_generation: int = betterproto.uint32_field(3)


@dataclass
class CBroadcast_WebRTCGetHostCandidates_Response(betterproto.Message):
    candidate_generation: int = betterproto.uint32_field(1)
    candidates: List["CBroadcast_WebRTC_Candidate"] = betterproto.message_field(2)


@dataclass
class CBroadcast_GetBroadcastUploadStats_Request(betterproto.Message):
    row_limit: int = betterproto.uint32_field(1)
    start_time: int = betterproto.uint32_field(2)
    upload_id: int = betterproto.uint64_field(3)
    steamid: float = betterproto.fixed64_field(4)
    session_id: int = betterproto.uint64_field(5)


@dataclass
class CBroadcast_GetBroadcastUploadStats_Response(betterproto.Message):
    upload_stats: List[
        "CBroadcast_GetBroadcastUploadStats_ResponseUploadStats"
    ] = betterproto.message_field(1)


@dataclass
class CBroadcast_GetBroadcastUploadStats_ResponseUploadStats(betterproto.Message):
    upload_result: int = betterproto.uint32_field(1)
    time_stopped: int = betterproto.uint32_field(2)
    seconds_uploaded: int = betterproto.uint32_field(3)
    max_viewers: int = betterproto.uint32_field(4)
    resolution_x: int = betterproto.uint32_field(5)
    resolution_y: int = betterproto.uint32_field(6)
    avg_bandwidth: int = betterproto.uint32_field(7)
    total_bytes: int = betterproto.uint64_field(8)
    app_id: int = betterproto.uint32_field(9)
    total_unique_viewers: int = betterproto.uint32_field(10)
    total_seconds_watched: int = betterproto.uint64_field(11)
    time_started: int = betterproto.uint32_field(12)
    upload_id: int = betterproto.uint64_field(13)
    local_address: str = betterproto.string_field(14)
    remote_address: str = betterproto.string_field(15)
    frames_per_second: int = betterproto.uint32_field(16)
    num_representations: int = betterproto.uint32_field(17)
    app_name: str = betterproto.string_field(18)
    is_replay: bool = betterproto.bool_field(19)
    session_id: int = betterproto.uint64_field(20)


@dataclass
class CBroadcast_GetBroadcastViewerStats_Request(betterproto.Message):
    upload_id: int = betterproto.uint64_field(1)
    steamid: float = betterproto.fixed64_field(2)


@dataclass
class CBroadcast_GetBroadcastViewerStats_Response(betterproto.Message):
    viewer_stats: List[
        "CBroadcast_GetBroadcastViewerStats_ResponseViewerStats"
    ] = betterproto.message_field(1)
    country_stats: List[
        "CBroadcast_GetBroadcastViewerStats_ResponseCountryStats"
    ] = betterproto.message_field(2)


@dataclass
class CBroadcast_GetBroadcastViewerStats_ResponseViewerStats(betterproto.Message):
    time: int = betterproto.uint32_field(1)
    num_viewers: int = betterproto.uint32_field(2)


@dataclass
class CBroadcast_GetBroadcastViewerStats_ResponseCountryStats(betterproto.Message):
    country_code: str = betterproto.string_field(1)
    num_viewers: int = betterproto.uint32_field(2)


@dataclass
class CBroadcast_BroadcastViewerState_Notification(betterproto.Message):
    steamid: float = betterproto.fixed64_field(1)
    state: "CBroadcast_BroadcastViewerState_NotificationEViewerState" = betterproto.enum_field(
        2
    )


@dataclass
class CBroadcast_WaitingBroadcastViewer_Notification(betterproto.Message):
    broadcast_id: float = betterproto.fixed64_field(1)


@dataclass
class CBroadcast_BroadcastUploadStarted_Notification(betterproto.Message):
    broadcast_id: float = betterproto.fixed64_field(1)
    upload_token: str = betterproto.string_field(2)
    upload_address: str = betterproto.string_field(3)
    http_address: str = betterproto.string_field(4)
    broadcast_upload_id: float = betterproto.fixed64_field(5)
    heartbeat_interval_seconds: int = betterproto.uint32_field(6)
    is_rtmp: bool = betterproto.bool_field(7)


@dataclass
class CBroadcast_StopBroadcastUpload_Notification(betterproto.Message):
    broadcast_id: float = betterproto.fixed64_field(1)
    broadcast_relay_id: float = betterproto.fixed64_field(2)
    upload_result: int = betterproto.uint32_field(3)
    too_many_poor_uploads: bool = betterproto.bool_field(4)


@dataclass
class CBroadcast_SessionClosed_Notification(betterproto.Message):
    broadcast_id: float = betterproto.fixed64_field(1)


@dataclass
class CBroadcast_ViewerBroadcastInvite_Notification(betterproto.Message):
    broadcaster_steamid: float = betterproto.fixed64_field(1)


@dataclass
class CBroadcast_BroadcastStatus_Notification(betterproto.Message):
    broadcast_id: float = betterproto.fixed64_field(1)
    num_viewers: int = betterproto.int32_field(2)


@dataclass
class CBroadcast_BroadcastChannelLive_Notification(betterproto.Message):
    broadcast_channel_id: float = betterproto.fixed64_field(1)
    broadcast_channel_name: str = betterproto.string_field(2)
    broadcast_channel_avatar: str = betterproto.string_field(3)


@dataclass
class CBroadcast_SendThumbnailToRelay_Notification(betterproto.Message):
    thumbnail_upload_token: str = betterproto.string_field(1)
    thumbnail_broadcast_session_id: float = betterproto.fixed64_field(2)
    thumbnail_data: bytes = betterproto.bytes_field(3)
    thumbnail_width: int = betterproto.uint32_field(4)
    thumbnail_height: int = betterproto.uint32_field(5)


@dataclass
class CBroadcast_WebRTCNeedTURNServer_Notification(betterproto.Message):
    broadcast_session_id: float = betterproto.fixed64_field(1)


@dataclass
class CBroadcast_WebRTCStart_Notification(betterproto.Message):
    broadcast_session_id: float = betterproto.fixed64_field(1)
    webrtc_session_id: float = betterproto.fixed64_field(2)
    viewer_steamid: float = betterproto.fixed64_field(3)
    viewer_token: float = betterproto.fixed64_field(4)


@dataclass
class CBroadcast_WebRTCSetAnswer_Notification(betterproto.Message):
    broadcast_session_id: float = betterproto.fixed64_field(1)
    webrtc_session_id: float = betterproto.fixed64_field(2)
    answer: str = betterproto.string_field(3)


@dataclass
class CBroadcast_WebRTCAddViewerCandidate_Notification(betterproto.Message):
    broadcast_session_id: float = betterproto.fixed64_field(1)
    webrtc_session_id: float = betterproto.fixed64_field(2)
    candidate: "CBroadcast_WebRTC_Candidate" = betterproto.message_field(3)


class BroadcastStub(betterproto.ServiceStub):
    async def begin_broadcast_session(
        self,
        *,
        permission: int = 0,
        gameid: int = 0,
        client_instance_id: int = 0,
        title: str = "",
        cellid: int = 0,
        rtmp_token: int = 0,
        thumbnail_upload: bool = False,
        client_beta: str = "",
        sysid: int = 0,
    ) -> CBroadcast_BeginBroadcastSession_Response:
        request = CBroadcast_BeginBroadcastSession_Request()
        request.permission = permission
        request.gameid = gameid
        request.client_instance_id = client_instance_id
        request.title = title
        request.cellid = cellid
        request.rtmp_token = rtmp_token
        request.thumbnail_upload = thumbnail_upload
        request.client_beta = client_beta
        request.sysid = sysid

        return await self._unary_unary(
            "/.Broadcast/BeginBroadcastSession",
            request,
            CBroadcast_BeginBroadcastSession_Response,
        )

    async def end_broadcast_session(
        self, *, broadcast_id: float = 0
    ) -> CBroadcast_EndBroadcastSession_Response:
        request = CBroadcast_EndBroadcastSession_Request()
        request.broadcast_id = broadcast_id

        return await self._unary_unary(
            "/.Broadcast/EndBroadcastSession",
            request,
            CBroadcast_EndBroadcastSession_Response,
        )

    async def start_broadcast_upload(
        self,
        *,
        broadcast_id: float = 0,
        cellid: int = 0,
        as_rtmp: bool = False,
        delay_seconds: int = 0,
        rtmp_token: int = 0,
        upload_ip_address: int = 0,
        is_replay: bool = False,
        sysid: int = 0,
    ) -> CBroadcast_StartBroadcastUpload_Response:
        request = CBroadcast_StartBroadcastUpload_Request()
        request.broadcast_id = broadcast_id
        request.cellid = cellid
        request.as_rtmp = as_rtmp
        request.delay_seconds = delay_seconds
        request.rtmp_token = rtmp_token
        request.upload_ip_address = upload_ip_address
        request.is_replay = is_replay
        request.sysid = sysid

        return await self._unary_unary(
            "/.Broadcast/StartBroadcastUpload",
            request,
            CBroadcast_StartBroadcastUpload_Response,
        )

    async def notify_broadcast_upload_stop(self, *, broadcast_upload_id: float = 0,
                                           upload_result: int = 0) -> NoResponse:
        request = CBroadcast_NotifyBroadcastUploadStop_Notification()
        request.broadcast_upload_id = broadcast_upload_id
        request.upload_result = upload_result

        return await self._unary_unary("/.Broadcast/NotifyBroadcastUploadStop", request, NoResponse)

    async def watch_broadcast(
        self,
        *,
        steamid: float = 0,
        existing_broadcast_id: float = 0,
        viewer_token: float = 0,
        client_ip: int = 0,
        client_cell: int = 0,
        watch_location: "EBroadcastWatchLocation" = 0,
        is_webrtc: bool = False,
    ) -> CBroadcast_WatchBroadcast_Response:
        request = CBroadcast_WatchBroadcast_Request()
        request.steamid = steamid
        request.existing_broadcast_id = existing_broadcast_id
        request.viewer_token = viewer_token
        request.client_ip = client_ip
        request.client_cell = client_cell
        request.watch_location = watch_location
        request.is_webrtc = is_webrtc

        return await self._unary_unary(
            "/.Broadcast/WatchBroadcast", request, CBroadcast_WatchBroadcast_Response,
        )

    async def heartbeat_broadcast(
        self,
        *,
        steamid: float = 0,
        broadcast_id: float = 0,
        viewer_token: float = 0,
        representation: int = 0,
    ) -> NoResponse:
        request = CBroadcast_HeartbeatBroadcast_Notification()
        request.steamid = steamid
        request.broadcast_id = broadcast_id
        request.viewer_token = viewer_token
        request.representation = representation

        return await self._unary_unary("/.Broadcast/HeartbeatBroadcast", request, NoResponse)

    async def stop_watching_broadcast(
        self, *, steamid: float = 0, broadcast_id: float = 0, viewer_token: float = 0
    ) -> NoResponse:
        request = CBroadcast_StopWatchingBroadcast_Notification()
        request.steamid = steamid
        request.broadcast_id = broadcast_id
        request.viewer_token = viewer_token

        return await self._unary_unary("/.Broadcast/StopWatchingBroadcast", request, NoResponse)

    async def get_broadcast_status(
        self, *, steamid: float = 0, broadcast_id: float = 0
    ) -> CBroadcast_GetBroadcastStatus_Response:
        request = CBroadcast_GetBroadcastStatus_Request()
        request.steamid = steamid
        request.broadcast_id = broadcast_id

        return await self._unary_unary(
            "/.Broadcast/GetBroadcastStatus",
            request,
            CBroadcast_GetBroadcastStatus_Response,
        )

    async def get_broadcast_thumbnail(
        self, *, steamid: float = 0, broadcast_id: float = 0
    ) -> CBroadcast_GetBroadcastThumbnail_Response:
        request = CBroadcast_GetBroadcastThumbnail_Request()
        request.steamid = steamid
        request.broadcast_id = broadcast_id

        return await self._unary_unary(
            "/.Broadcast/GetBroadcastThumbnail",
            request,
            CBroadcast_GetBroadcastThumbnail_Response,
        )

    async def invite_to_broadcast(
        self, *, steamid: float = 0, approval_response: bool = False
    ) -> CBroadcast_InviteToBroadcast_Response:
        request = CBroadcast_InviteToBroadcast_Request()
        request.steamid = steamid
        request.approval_response = approval_response

        return await self._unary_unary(
            "/.Broadcast/InviteToBroadcast",
            request,
            CBroadcast_InviteToBroadcast_Response,
        )

    async def send_broadcast_state_to_server(
        self,
        *,
        permission: int = 0,
        gameid: int = 0,
        title: str = "",
        game_data_config: str = "",
    ) -> CBroadcast_SendBroadcastStateToServer_Response:
        request = CBroadcast_SendBroadcastStateToServer_Request()
        request.permission = permission
        request.gameid = gameid
        request.title = title
        request.game_data_config = game_data_config

        return await self._unary_unary(
            "/.Broadcast/SendBroadcastStateToServer",
            request,
            CBroadcast_SendBroadcastStateToServer_Response,
        )

    async def notify_broadcast_session_heartbeat(
        self, *, broadcast_id: float = 0
    ) -> NoResponse:
        request = CBroadcast_NotifyBroadcastSessionHeartbeat_Notification()
        request.broadcast_id = broadcast_id

        return await self._unary_unary(
            "/.Broadcast/NotifyBroadcastSessionHeartbeat", request, NoResponse,
        )

    async def get_broadcast_chat_info(
        self,
        *,
        steamid: float = 0,
        broadcast_id: float = 0,
        client_ip: int = 0,
        client_cell: int = 0,
    ) -> CBroadcast_GetBroadcastChatInfo_Response:
        request = CBroadcast_GetBroadcastChatInfo_Request()
        request.steamid = steamid
        request.broadcast_id = broadcast_id
        request.client_ip = client_ip
        request.client_cell = client_cell

        return await self._unary_unary(
            "/.Broadcast/GetBroadcastChatInfo",
            request,
            CBroadcast_GetBroadcastChatInfo_Response,
        )

    async def post_chat_message(
        self,
        *,
        chat_id: float = 0,
        message: str = "",
        instance_id: int = 0,
        language: int = 0,
        country_code: str = "",
    ) -> CBroadcast_PostChatMessage_Response:
        request = CBroadcast_PostChatMessage_Request()
        request.chat_id = chat_id
        request.message = message
        request.instance_id = instance_id
        request.language = language
        request.country_code = country_code

        return await self._unary_unary(
            "/.Broadcast/PostChatMessage", request, CBroadcast_PostChatMessage_Response,
        )

    async def update_chat_message_flair(
        self, *, chat_id: float = 0, flair: str = ""
    ) -> CBroadcast_UpdateChatMessageFlair_Response:
        request = CBroadcast_UpdateChatMessageFlair_Request()
        request.chat_id = chat_id
        request.flair = flair

        return await self._unary_unary(
            "/.Broadcast/UpdateChatMessageFlair",
            request,
            CBroadcast_UpdateChatMessageFlair_Response,
        )

    async def mute_broadcast_chat_user(
        self, *, chat_id: float = 0, user_steamid: float = 0, muted: bool = False
    ) -> CBroadcast_MuteBroadcastChatUser_Response:
        request = CBroadcast_MuteBroadcastChatUser_Request()
        request.chat_id = chat_id
        request.user_steamid = user_steamid
        request.muted = muted

        return await self._unary_unary(
            "/.Broadcast/MuteBroadcastChatUser",
            request,
            CBroadcast_MuteBroadcastChatUser_Response,
        )

    async def remove_user_chat_text(
        self, *, chat_id: float = 0, user_steamid: float = 0
    ) -> CBroadcast_RemoveUserChatText_Response:
        request = CBroadcast_RemoveUserChatText_Request()
        request.chat_id = chat_id
        request.user_steamid = user_steamid

        return await self._unary_unary(
            "/.Broadcast/RemoveUserChatText",
            request,
            CBroadcast_RemoveUserChatText_Response,
        )

    async def get_broadcast_chat_user_names(
        self, *, chat_id: float = 0, user_steamid: List[float] = []
    ) -> CBroadcast_GetBroadcastChatUserNames_Response:
        request = CBroadcast_GetBroadcastChatUserNames_Request()
        request.chat_id = chat_id
        request.user_steamid = user_steamid

        return await self._unary_unary(
            "/.Broadcast/GetBroadcastChatUserNames",
            request,
            CBroadcast_GetBroadcastChatUserNames_Response,
        )

    async def start_build_clip(
        self,
        *,
        steamid: float = 0,
        broadcast_session_id: float = 0,
        first_segment: int = 0,
        num_segments: int = 0,
        clip_description: str = "",
    ) -> CBroadcast_StartBuildClip_Response:
        request = CBroadcast_StartBuildClip_Request()
        request.steamid = steamid
        request.broadcast_session_id = broadcast_session_id
        request.first_segment = first_segment
        request.num_segments = num_segments
        request.clip_description = clip_description

        return await self._unary_unary(
            "/.Broadcast/StartBuildClip", request, CBroadcast_StartBuildClip_Response,
        )

    async def get_build_clip_status(
        self, *, broadcast_clip_id: float = 0
    ) -> CBroadcast_GetBuildClipStatus_Response:
        request = CBroadcast_GetBuildClipStatus_Request()
        request.broadcast_clip_id = broadcast_clip_id

        return await self._unary_unary(
            "/.Broadcast/GetBuildClipStatus",
            request,
            CBroadcast_GetBuildClipStatus_Response,
        )

    async def set_clip_details(
        self,
        *,
        broadcast_clip_id: int = 0,
        start_time: int = 0,
        end_time: int = 0,
        video_description: str = "",
    ) -> CBroadcast_SetClipDetails_Response:
        request = CBroadcast_SetClipDetails_Request()
        request.broadcast_clip_id = broadcast_clip_id
        request.start_time = start_time
        request.end_time = end_time
        request.video_description = video_description

        return await self._unary_unary(
            "/.Broadcast/SetClipDetails", request, CBroadcast_SetClipDetails_Response,
        )

    async def get_clip_details(
        self, *, broadcast_clip_id: int = 0
    ) -> CBroadcast_GetClipDetails_Response:
        request = CBroadcast_GetClipDetails_Request()
        request.broadcast_clip_id = broadcast_clip_id

        return await self._unary_unary(
            "/.Broadcast/GetClipDetails", request, CBroadcast_GetClipDetails_Response,
        )

    async def set_r_t_m_p_info(
        self,
        *,
        broadcast_permission: int = 0,
        update_token: bool = False,
        broadcast_delay: int = 0,
        app_id: int = 0,
        required_app_id: int = 0,
        broadcast_chat_permission: "EBroadcastChatPermission" = 0,
        broadcast_buffer: int = 0,
        steamid: float = 0,
        chat_rate_limit: int = 0,
        enable_replay: bool = False,
    ) -> CBroadcast_SetRTMPInfo_Response:
        request = CBroadcast_SetRTMPInfo_Request()
        request.broadcast_permission = broadcast_permission
        request.update_token = update_token
        request.broadcast_delay = broadcast_delay
        request.app_id = app_id
        request.required_app_id = required_app_id
        request.broadcast_chat_permission = broadcast_chat_permission
        request.broadcast_buffer = broadcast_buffer
        request.steamid = steamid
        request.chat_rate_limit = chat_rate_limit
        request.enable_replay = enable_replay

        return await self._unary_unary(
            "/.Broadcast/SetRTMPInfo", request, CBroadcast_SetRTMPInfo_Response,
        )

    async def get_r_t_m_p_info(
        self, *, ip: int = 0, steamid: float = 0
    ) -> CBroadcast_GetRTMPInfo_Response:
        request = CBroadcast_GetRTMPInfo_Request()
        request.ip = ip
        request.steamid = steamid

        return await self._unary_unary(
            "/.Broadcast/GetRTMPInfo", request, CBroadcast_GetRTMPInfo_Response,
        )

    async def notify_web_r_t_c_have_t_u_r_n_server(
        self, *, broadcast_session_id: float = 0, turn_server: str = ""
    ) -> NoResponse:
        request = CBroadcast_WebRTCHaveTURNServer_Notification()
        request.broadcast_session_id = broadcast_session_id
        request.turn_server = turn_server

        return await self._unary_unary(
            "/.Broadcast/NotifyWebRTCHaveTURNServer", request, NoResponse,
        )

    async def web_r_t_c_start_result(
        self,
        *,
        webrtc_session_id: float = 0,
        started: bool = False,
        offer: str = "",
        resolution_x: int = 0,
        resolution_y: int = 0,
        fps: int = 0,
    ) -> CBroadcast_WebRTCStartResult_Response:
        request = CBroadcast_WebRTCStartResult_Request()
        request.webrtc_session_id = webrtc_session_id
        request.started = started
        request.offer = offer
        request.resolution_x = resolution_x
        request.resolution_y = resolution_y
        request.fps = fps

        return await self._unary_unary(
            "/.Broadcast/WebRTCStartResult",
            request,
            CBroadcast_WebRTCStartResult_Response,
        )

    async def web_r_t_c_stopped(
        self, *, webrtc_session_id: float = 0
    ) -> CBroadcast_WebRTCStopped_Response:
        request = CBroadcast_WebRTCStopped_Request()
        request.webrtc_session_id = webrtc_session_id

        return await self._unary_unary(
            "/.Broadcast/WebRTCStopped", request, CBroadcast_WebRTCStopped_Response,
        )

    async def web_r_t_c_set_answer(
        self,
        *,
        broadcaster_steamid: float = 0,
        webrtc_session_id: float = 0,
        answer: str = "",
    ) -> CBroadcast_WebRTCSetAnswer_Response:
        request = CBroadcast_WebRTCSetAnswer_Request()
        request.broadcaster_steamid = broadcaster_steamid
        request.webrtc_session_id = webrtc_session_id
        request.answer = answer

        return await self._unary_unary(
            "/.Broadcast/WebRTCSetAnswer", request, CBroadcast_WebRTCSetAnswer_Response,
        )

    async def web_r_t_c_lookup_t_u_r_n_server(
        self, *, cellid: int = 0
    ) -> CBroadcast_WebRTCLookupTURNServer_Response:
        request = CBroadcast_WebRTCLookupTURNServer_Request()
        request.cellid = cellid

        return await self._unary_unary(
            "/.Broadcast/WebRTCLookupTURNServer",
            request,
            CBroadcast_WebRTCLookupTURNServer_Response,
        )

    async def web_r_t_c_add_host_candidate(
        self,
        *,
        webrtc_session_id: float = 0,
        candidate: Optional["CBroadcast_WebRTC_Candidate"] = None,
    ) -> CBroadcast_WebRTCAddHostCandidate_Response:
        request = CBroadcast_WebRTCAddHostCandidate_Request()
        request.webrtc_session_id = webrtc_session_id
        if candidate is not None:
            request.candidate = candidate

        return await self._unary_unary(
            "/.Broadcast/WebRTCAddHostCandidate",
            request,
            CBroadcast_WebRTCAddHostCandidate_Response,
        )

    async def web_r_t_c_add_viewer_candidate(
        self,
        *,
        broadcaster_steamid: float = 0,
        webrtc_session_id: float = 0,
        candidate: Optional["CBroadcast_WebRTC_Candidate"] = None,
    ) -> CBroadcast_WebRTCAddViewerCandidate_Response:
        request = CBroadcast_WebRTCAddViewerCandidate_Request()
        request.broadcaster_steamid = broadcaster_steamid
        request.webrtc_session_id = webrtc_session_id
        if candidate is not None:
            request.candidate = candidate

        return await self._unary_unary(
            "/.Broadcast/WebRTCAddViewerCandidate",
            request,
            CBroadcast_WebRTCAddViewerCandidate_Response,
        )

    async def web_r_t_c_get_host_candidates(
        self,
        *,
        broadcaster_steamid: float = 0,
        webrtc_session_id: float = 0,
        candidate_generation: int = 0,
    ) -> CBroadcast_WebRTCGetHostCandidates_Response:
        request = CBroadcast_WebRTCGetHostCandidates_Request()
        request.broadcaster_steamid = broadcaster_steamid
        request.webrtc_session_id = webrtc_session_id
        request.candidate_generation = candidate_generation

        return await self._unary_unary(
            "/.Broadcast/WebRTCGetHostCandidates",
            request,
            CBroadcast_WebRTCGetHostCandidates_Response,
        )

    async def get_broadcast_upload_stats(
        self,
        *,
        row_limit: int = 0,
        start_time: int = 0,
        upload_id: int = 0,
        steamid: float = 0,
        session_id: int = 0,
    ) -> CBroadcast_GetBroadcastUploadStats_Response:
        request = CBroadcast_GetBroadcastUploadStats_Request()
        request.row_limit = row_limit
        request.start_time = start_time
        request.upload_id = upload_id
        request.steamid = steamid
        request.session_id = session_id

        return await self._unary_unary(
            "/.Broadcast/GetBroadcastUploadStats",
            request,
            CBroadcast_GetBroadcastUploadStats_Response,
        )

    async def get_broadcast_viewer_stats(
        self, *, upload_id: int = 0, steamid: float = 0
    ) -> CBroadcast_GetBroadcastViewerStats_Response:
        request = CBroadcast_GetBroadcastViewerStats_Request()
        request.upload_id = upload_id
        request.steamid = steamid

        return await self._unary_unary(
            "/.Broadcast/GetBroadcastViewerStats",
            request,
            CBroadcast_GetBroadcastViewerStats_Response,
        )


class BroadcastClientStub(betterproto.ServiceStub):
    async def notify_broadcast_viewer_state(
        self,
        *,
        steamid: float = 0,
        state: "CBroadcast_BroadcastViewerState_NotificationEViewerState" = 0,
    ) -> NoResponse:
        request = CBroadcast_BroadcastViewerState_Notification()
        request.steamid = steamid
        request.state = state

        return await self._unary_unary(
            "/.BroadcastClient/NotifyBroadcastViewerState", request, NoResponse,
        )

    async def notify_waiting_broadcast_viewer(
        self, *, broadcast_id: float = 0
    ) -> NoResponse:
        request = CBroadcast_WaitingBroadcastViewer_Notification()
        request.broadcast_id = broadcast_id

        return await self._unary_unary(
            "/.BroadcastClient/NotifyWaitingBroadcastViewer", request, NoResponse,
        )

    async def notify_broadcast_upload_started(
        self,
        *,
        broadcast_id: float = 0,
        upload_token: str = "",
        upload_address: str = "",
        http_address: str = "",
        broadcast_upload_id: float = 0,
        heartbeat_interval_seconds: int = 0,
        is_rtmp: bool = False,
    ) -> NoResponse:
        request = CBroadcast_BroadcastUploadStarted_Notification()
        request.broadcast_id = broadcast_id
        request.upload_token = upload_token
        request.upload_address = upload_address
        request.http_address = http_address
        request.broadcast_upload_id = broadcast_upload_id
        request.heartbeat_interval_seconds = heartbeat_interval_seconds
        request.is_rtmp = is_rtmp

        return await self._unary_unary(
            "/.BroadcastClient/NotifyBroadcastUploadStarted", request, NoResponse,
        )

    async def notify_stop_broadcast_upload(
        self,
        *,
        broadcast_id: float = 0,
        broadcast_relay_id: float = 0,
        upload_result: int = 0,
        too_many_poor_uploads: bool = False,
    ) -> NoResponse:
        request = CBroadcast_StopBroadcastUpload_Notification()
        request.broadcast_id = broadcast_id
        request.broadcast_relay_id = broadcast_relay_id
        request.upload_result = upload_result
        request.too_many_poor_uploads = too_many_poor_uploads

        return await self._unary_unary(
            "/.BroadcastClient/NotifyStopBroadcastUpload", request, NoResponse,
        )

    async def notify_session_closed(self, *, broadcast_id: float = 0) -> NoResponse:
        request = CBroadcast_SessionClosed_Notification()
        request.broadcast_id = broadcast_id

        return await self._unary_unary(
            "/.BroadcastClient/NotifySessionClosed", request, NoResponse,
        )

    async def notify_viewer_broadcast_invite(
        self, *, broadcaster_steamid: float = 0
    ) -> NoResponse:
        request = CBroadcast_ViewerBroadcastInvite_Notification()
        request.broadcaster_steamid = broadcaster_steamid

        return await self._unary_unary(
            "/.BroadcastClient/NotifyViewerBroadcastInvite", request, NoResponse,
        )

    async def notify_broadcast_status(
        self, *, broadcast_id: float = 0, num_viewers: int = 0
    ) -> NoResponse:
        request = CBroadcast_BroadcastStatus_Notification()
        request.broadcast_id = broadcast_id
        request.num_viewers = num_viewers

        return await self._unary_unary(
            "/.BroadcastClient/NotifyBroadcastStatus", request, NoResponse,
        )

    async def notify_broadcast_channel_live(
        self,
        *,
        broadcast_channel_id: float = 0,
        broadcast_channel_name: str = "",
        broadcast_channel_avatar: str = "",
    ) -> NoResponse:
        request = CBroadcast_BroadcastChannelLive_Notification()
        request.broadcast_channel_id = broadcast_channel_id
        request.broadcast_channel_name = broadcast_channel_name
        request.broadcast_channel_avatar = broadcast_channel_avatar

        return await self._unary_unary(
            "/.BroadcastClient/NotifyBroadcastChannelLive", request, NoResponse,
        )

    async def send_thumbnail_to_relay(
        self,
        *,
        thumbnail_upload_token: str = "",
        thumbnail_broadcast_session_id: float = 0,
        thumbnail_data: bytes = b"",
        thumbnail_width: int = 0,
        thumbnail_height: int = 0,
    ) -> NoResponse:
        request = CBroadcast_SendThumbnailToRelay_Notification()
        request.thumbnail_upload_token = thumbnail_upload_token
        request.thumbnail_broadcast_session_id = thumbnail_broadcast_session_id
        request.thumbnail_data = thumbnail_data
        request.thumbnail_width = thumbnail_width
        request.thumbnail_height = thumbnail_height

        return await self._unary_unary(
            "/.BroadcastClient/SendThumbnailToRelay", request, NoResponse,
        )

    async def notify_web_r_t_c_need_t_u_r_n_server(
        self, *, broadcast_session_id: float = 0
    ) -> NoResponse:
        request = CBroadcast_WebRTCNeedTURNServer_Notification()
        request.broadcast_session_id = broadcast_session_id

        return await self._unary_unary(
            "/.BroadcastClient/NotifyWebRTCNeedTURNServer", request, NoResponse,
        )

    async def notify_web_r_t_c_start(
        self,
        *,
        broadcast_session_id: float = 0,
        webrtc_session_id: float = 0,
        viewer_steamid: float = 0,
        viewer_token: float = 0,
    ) -> NoResponse:
        request = CBroadcast_WebRTCStart_Notification()
        request.broadcast_session_id = broadcast_session_id
        request.webrtc_session_id = webrtc_session_id
        request.viewer_steamid = viewer_steamid
        request.viewer_token = viewer_token

        return await self._unary_unary(
            "/.BroadcastClient/NotifyWebRTCStart", request, NoResponse,
        )

    async def notify_web_r_t_c_set_answer(
        self,
        *,
        broadcast_session_id: float = 0,
        webrtc_session_id: float = 0,
        answer: str = "",
    ) -> NoResponse:
        request = CBroadcast_WebRTCSetAnswer_Notification()
        request.broadcast_session_id = broadcast_session_id
        request.webrtc_session_id = webrtc_session_id
        request.answer = answer

        return await self._unary_unary(
            "/.BroadcastClient/NotifyWebRTCSetAnswer", request, NoResponse,
        )

    async def notify_web_r_t_c_add_viewer_candidate(
        self,
        *,
        broadcast_session_id: float = 0,
        webrtc_session_id: float = 0,
        candidate: Optional["CBroadcast_WebRTC_Candidate"] = None,
    ) -> NoResponse:
        request = CBroadcast_WebRTCAddViewerCandidate_Notification()
        request.broadcast_session_id = broadcast_session_id
        request.webrtc_session_id = webrtc_session_id
        if candidate is not None:
            request.candidate = candidate

        return await self._unary_unary(
            "/.BroadcastClient/NotifyWebRTCAddViewerCandidate", request, NoResponse,
        )
